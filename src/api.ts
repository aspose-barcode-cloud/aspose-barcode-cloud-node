/*
* MIT License

* Copyright (c) 2018 Aspose Pty Ltd

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:

* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

import localVarRequest = require('request');
import http = require('http');
import { Configuration, ApiVersion } from './configuration';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return enumsMap[type][data];
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}



/**
* Represents the basic response class from Aspose for Cloud.
*/
export class AsposeResponse {
    'code': HttpStatusCode;
    'status'?: string;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "Code",
            "type": "HttpStatusCode"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AsposeResponse.attributeTypeMap;
    }
}

/**
* Represents BarCodeBuilder.
*/
export class BarCodeBuilder {
    /**
    * Gets or sets type of barcode to generate.
    */
    'typeOfBarCode': BarCodeType;
    /**
    * Gets or sets text to encode.
    */
    'text'?: string;
    /**
    * Gets or sets  parameters.>
    */
    'resolution'?: Resolution;
    /**
    * Gets or sets smallest width unit of barcode.
    */
    'dimensionX'?: number;
    /**
    * Gets or sets smallest height unit of barcode.
    */
    'dimensionY'?: number;
    /**
    * Gets or sets  of barcode.
    */
    'codeLocation'?: CodeLocation;
    /**
    * Gets or sets  for barcode dimension parameers.
    */
    'graphicsUnit'?: GraphicsUnit;
    /**
    * Gets or sets a value indicating whether size of barcode changes automatically.
    */
    'autoSize'?: boolean;
    /**
    * Gets or sets height of the barcode.
    */
    'barHeight'?: number;
    /**
    * Gets or sets height of the barcode image.
    */
    'imageHeight'?: number;
    /**
    * Gets or sets width of the barcode image.
    */
    'imageWidth'?: number;
    /**
    * Gets or sets  of the image.
    */
    'imageQuality'?: ImageQualityMode;
    /**
    * Gets or sets angle of barcode orientation.
    */
    'rotationAngle'?: number;
    /**
    * Gets or sets  around barcode.
    */
    'margins'?: Margins;
    /**
    * Gets or sets background color.
    */
    'backColor'?: string;
    /**
    * Gets or sets foreground color.
    */
    'foreColor'?: string;
    /**
    * Gets or sets color of the code text.
    */
    'codeTextColor'?: string;
    /**
    * Gets or sets color of the border.
    */
    'borderColor'?: string;
    /**
    * Gets or sets a value indicating whether border is visible.
    */
    'borderVisible'?: boolean;
    /**
    * Gets or sets a value indicating whether checksum is enabled.
    */
    'enableChecksum'?: EnableChecksum;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "typeOfBarCode",
            "baseName": "TypeOfBarCode",
            "type": "BarCodeType"
        },
        {
            "name": "text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "resolution",
            "baseName": "Resolution",
            "type": "Resolution"
        },
        {
            "name": "dimensionX",
            "baseName": "DimensionX",
            "type": "number"
        },
        {
            "name": "dimensionY",
            "baseName": "DimensionY",
            "type": "number"
        },
        {
            "name": "codeLocation",
            "baseName": "CodeLocation",
            "type": "CodeLocation"
        },
        {
            "name": "graphicsUnit",
            "baseName": "GraphicsUnit",
            "type": "GraphicsUnit"
        },
        {
            "name": "autoSize",
            "baseName": "AutoSize",
            "type": "boolean"
        },
        {
            "name": "barHeight",
            "baseName": "BarHeight",
            "type": "number"
        },
        {
            "name": "imageHeight",
            "baseName": "ImageHeight",
            "type": "number"
        },
        {
            "name": "imageWidth",
            "baseName": "ImageWidth",
            "type": "number"
        },
        {
            "name": "imageQuality",
            "baseName": "ImageQuality",
            "type": "ImageQualityMode"
        },
        {
            "name": "rotationAngle",
            "baseName": "RotationAngle",
            "type": "number"
        },
        {
            "name": "margins",
            "baseName": "Margins",
            "type": "Margins"
        },
        {
            "name": "backColor",
            "baseName": "BackColor",
            "type": "string"
        },
        {
            "name": "foreColor",
            "baseName": "ForeColor",
            "type": "string"
        },
        {
            "name": "codeTextColor",
            "baseName": "CodeTextColor",
            "type": "string"
        },
        {
            "name": "borderColor",
            "baseName": "BorderColor",
            "type": "string"
        },
        {
            "name": "borderVisible",
            "baseName": "BorderVisible",
            "type": "boolean"
        },
        {
            "name": "enableChecksum",
            "baseName": "EnableChecksum",
            "type": "EnableChecksum"
        }    ];

    static getAttributeTypeMap() {
        return BarCodeBuilder.attributeTypeMap;
    }
}

/**
* Represents list of barcode builders
*/
export class BarCodeBuildersList {
    /**
    * List of barcode builders
    */
    'barCodeBuilders'?: Array<BarCodeBuilder>;
    /**
    * Shift step according to X axis
    */
    'xStep': number;
    /**
    * Shift step according to Y axis
    */
    'yStep': number;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "barCodeBuilders",
            "baseName": "BarCodeBuilders",
            "type": "Array<BarCodeBuilder>"
        },
        {
            "name": "xStep",
            "baseName": "XStep",
            "type": "number"
        },
        {
            "name": "yStep",
            "baseName": "YStep",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BarCodeBuildersList.attributeTypeMap;
    }
}

/**
* Represents BarCodeReader object.
*/
export class BarCodeReader {
    /**
    * Gets or sets ChecksumValidation property.
    */
    'checksumValidation'?: ChecksumValidation;
    /**
    * Gets or sets a value indicating whether FNC symbol strip must be done.
    */
    'stripFNC'?: boolean;
    /**
    * Gets or sets count of barcodes to recognize.
    */
    'barCodesCount'?: number;
    /**
    * Gets or sets rotation correction angle.
    */
    'rotationAngle'?: number;
    /**
    * Gets or sets recognition mode.
    */
    'recognitionMode'?: RecognitionMode;
    /**
    * Gets or sets manual hints.
    */
    'manualHints'?: ManualHints;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checksumValidation",
            "baseName": "ChecksumValidation",
            "type": "ChecksumValidation"
        },
        {
            "name": "stripFNC",
            "baseName": "StripFNC",
            "type": "boolean"
        },
        {
            "name": "barCodesCount",
            "baseName": "BarCodesCount",
            "type": "number"
        },
        {
            "name": "rotationAngle",
            "baseName": "RotationAngle",
            "type": "number"
        },
        {
            "name": "recognitionMode",
            "baseName": "RecognitionMode",
            "type": "RecognitionMode"
        },
        {
            "name": "manualHints",
            "baseName": "ManualHints",
            "type": "ManualHints"
        }    ];

    static getAttributeTypeMap() {
        return BarCodeReader.attributeTypeMap;
    }
}

/**
* Represents information about barcode.
*/
export class BarCodeResponse {
    /**
    * Gets or sets barcode data.
    */
    'barCodeValue'?: string;
    /**
    * Gets or sets type of the barcode.
    */
    'barCodeType'?: string;
    /**
    * Gets or sets region with barcode.
    */
    'region'?: Array<Point>;
    /**
    * Gets or sets checksum of barcode.
    */
    'checksum'?: string;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "barCodeValue",
            "baseName": "BarCodeValue",
            "type": "string"
        },
        {
            "name": "barCodeType",
            "baseName": "BarCodeType",
            "type": "string"
        },
        {
            "name": "region",
            "baseName": "Region",
            "type": "Array<Point>"
        },
        {
            "name": "checksum",
            "baseName": "Checksum",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BarCodeResponse.attributeTypeMap;
    }
}

/**
* Supported types of barcode for generation.
*/
export enum BarCodeType	{
	AustraliaPost,
	AustralianPosteParcel,
	Aztec,
	BooklandEAN,
	Codabar,
	Code11,
	Code16K,
	Code128,
	CodablockF,
	Code39Extended,
	Code39Standard,
	Code93Extended,
	Code93Standard,
	CompactPdf417,
	DatabarOmniDirectional,
	DatabarTruncated,
	DatabarLimited,
	DatabarExpanded,
	DatabarExpandedStacked,
	DatabarStacked,
	DatabarStackedOmniDirectional,
	DataMatrix,
	DeutschePostIdentcode,
	DeutschePostLeitcode,
	EAN128,
	EAN13,
	EAN14,
	EAN8,
	GS1Code128,
	GS1CodablockF,
	GS1DataMatrix,
	GS1QR,
	IATA2of5,
	ISBN,
	ISMN,
	ISSN,
	ITF14,
	ITF6,
	Interleaved2of5,
	ItalianPost25,
	MaxiCode,
	MSI,
	MicroPdf417,
	MacroPdf417,
	Matrix2of5,
	MicroQR,
	OPC,
	OneCode,
	PZN,
	PatchCode,
	Pharmacode,
	Pdf417,
	Planet,
	Postnet,
	QR,
	RM4SCC,
	SingaporePost,
	SCC14,
	SSCC18,
	Standard2of5,
	SwissPostParcel,
	UPCA,
	UPCE,
	VIN,
	Code32,
	Datalogic2of5,
	DotCode,
	DutchKIX
  }

/**
* Represents checksum validation property.
*/
export enum ChecksumValidation	{
	Default,
	On,
	Off
  }

/**
* Represents states of code location.
*/
export enum CodeLocation	{
	Above,
	Below,
	None
  }

/**
* Represents checksum property.
*/
export enum EnableChecksum	{
	Default,
	Yes,
	No
  }

/**
* 
*/
export enum GraphicsUnit	{
	World,
	Display,
	Pixel,
	Point,
	Inch,
	Document,
	Millimeter
  }

/**
* 
*/
export enum HttpStatusCode	{
	Continue,
	SwitchingProtocols,
	OK,
	Created,
	Accepted,
	NonAuthoritativeInformation,
	NoContent,
	ResetContent,
	PartialContent,
	MultipleChoices,
	Ambiguous,
	MovedPermanently,
	Moved,
	Found,
	Redirect,
	SeeOther,
	RedirectMethod,
	NotModified,
	UseProxy,
	Unused,
	TemporaryRedirect,
	RedirectKeepVerb,
	BadRequest,
	Unauthorized,
	PaymentRequired,
	Forbidden,
	NotFound,
	MethodNotAllowed,
	NotAcceptable,
	ProxyAuthenticationRequired,
	RequestTimeout,
	Conflict,
	Gone,
	LengthRequired,
	PreconditionFailed,
	RequestEntityTooLarge,
	RequestUriTooLong,
	UnsupportedMediaType,
	RequestedRangeNotSatisfiable,
	ExpectationFailed,
	UpgradeRequired,
	InternalServerError,
	NotImplemented,
	BadGateway,
	ServiceUnavailable,
	GatewayTimeout,
	HttpVersionNotSupported
  }

/**
* Represents type of image quality.
*/
export enum ImageQualityMode	{
	Default,
	AntiAlias
  }

/**
* Represents the usage of manual hints.
*/
export enum ManualHints	{
	None,
	InvertImage,
	IncorrectBarCodes,
	ComplexBackground,
	MedianSmoothing,
	SpecialFormOfCells,
	UseRegular,
	UseRestoration,
	SkipRotatedBarCodes
  }

/**
* Represents margins around barcode.
*/
export class Margins {
    /**
    * Gets or sets left margin.
    */
    'left': number;
    /**
    * Gets or sets Right margin.
    */
    'right': number;
    /**
    * Gets or sets top margin.
    */
    'top': number;
    /**
    * Gets or sets bottom margin.
    */
    'bottom': number;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "left",
            "baseName": "Left",
            "type": "number"
        },
        {
            "name": "right",
            "baseName": "Right",
            "type": "number"
        },
        {
            "name": "top",
            "baseName": "Top",
            "type": "number"
        },
        {
            "name": "bottom",
            "baseName": "Bottom",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Margins.attributeTypeMap;
    }
}

/**
* Represents the usage of recognition modes
*/
export enum RecognitionMode	{
	MaxPerformance,
	MaxBarCodes,
	MaxQuality,
	ManualHints
  }

/**
* Represents resolutions of barcode.
*/
export class Resolution {
    /**
    * Gets or sets resolution along X axis.
    */
    'resolutionX': number;
    /**
    * Gets or sets resolution along Y axis.
    */
    'resolutionY': number;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resolutionX",
            "baseName": "ResolutionX",
            "type": "number"
        },
        {
            "name": "resolutionY",
            "baseName": "ResolutionY",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Resolution.attributeTypeMap;
    }
}
export class ValueType {


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ValueType.attributeTypeMap;
    }
}

/**
* Represents information about barcode list.
*/
export class BarCodeResponseList extends AsposeResponse {
    /**
    * List of barcodes which are present in image.
    */
    'barCodes'?: Array<BarCodeResponse>;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "barCodes",
            "baseName": "BarCodes",
            "type": "Array<BarCodeResponse>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BarCodeResponseList.attributeTypeMap);
    }
}
export class Point extends ValueType {
    'isEmpty'?: boolean;
    'X'?: number;
    'Y'?: number;


    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isEmpty",
            "baseName": "IsEmpty",
            "type": "boolean"
        },
        {
            "name": "X",
            "baseName": "X",
            "type": "number"
        },
        {
            "name": "Y",
            "baseName": "Y",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Point.attributeTypeMap);
    }
}

let enumsMap: {[index: string]: any} = {
        "BarCodeType": BarCodeType,
        "ChecksumValidation": ChecksumValidation,
        "CodeLocation": CodeLocation,
        "EnableChecksum": EnableChecksum,
        "GraphicsUnit": GraphicsUnit,
        "HttpStatusCode": HttpStatusCode,
        "ImageQualityMode": ImageQualityMode,
        "ManualHints": ManualHints,
        "RecognitionMode": RecognitionMode,
}

let typeMap: {[index: string]: any} = {
		"AsposeResponse": AsposeResponse,
		"BarCodeBuilder": BarCodeBuilder,
		"BarCodeBuildersList": BarCodeBuildersList,
		"BarCodeReader": BarCodeReader,
		"BarCodeResponse": BarCodeResponse,
		"Margins": Margins,
		"Resolution": Resolution,
		"ValueType": ValueType,
		"BarCodeResponseList": BarCodeResponseList,
		"Point": Point,
}

export enum BarCodeApiApiKeys {
    appsid,
    signature,
}

export class BarCodeApi {

	protected defaultHeaders : any = {};
    protected _configuration : Configuration;


    constructor(configuration: Configuration)
    {
        this._configuration = configuration;
	}

    /**
     * 
     * @summary Generate barcode.
     * @param text The code text.
     * @param type BarCode type.
     * @param format Result format.
     * @param resolutionX Horizontal resolution.
     * @param resolutionY Vertical resolution.
     * @param dimensionX Smallest width of barcode unit (bar or space).
     * @param dimensionY Smallest height of barcode unit (for 2D barcodes).
     * @param enableChecksum Sets if checksum will be generated.
     */
    public async barCodeGetBarCodeGenerate (text?: string, type?: string, format?: string, resolutionX?: number, resolutionY?: number, dimensionX?: number, dimensionY?: number, enableChecksum?: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/generate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (text !== undefined) {
            localVarQueryParameters['text'] = ObjectSerializer.serialize(text, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (format !== undefined) {
            localVarQueryParameters['format'] = ObjectSerializer.serialize(format, "string");
        }

        if (resolutionX !== undefined) {
            localVarQueryParameters['resolutionX'] = ObjectSerializer.serialize(resolutionX, "number");
        }

        if (resolutionY !== undefined) {
            localVarQueryParameters['resolutionY'] = ObjectSerializer.serialize(resolutionY, "number");
        }

        if (dimensionX !== undefined) {
            localVarQueryParameters['dimensionX'] = ObjectSerializer.serialize(dimensionX, "number");
        }

        if (dimensionY !== undefined) {
            localVarQueryParameters['dimensionY'] = ObjectSerializer.serialize(dimensionY, "number");
        }

        if (enableChecksum !== undefined) {
            localVarQueryParameters['enableChecksum'] = ObjectSerializer.serialize(enableChecksum, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
            encoding: null,
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
    /**
     * 
     * @summary Recognize barcode from a file on server.
     * @param name The image name.
     * @param type The barcode type.
     * @param checksumValidation Checksum validation parameter.
     * @param stripFnc Allows to strip FNC symbol in recognition results.
     * @param rotationAngle Allows to correct angle of barcode.
     * @param barcodesCount Count of barcodes to recognize.
     * @param rectX Top left point X coordinate of  to recognize barcode inside.
     * @param rectY Top left point Y coordinate of  to recognize barcode inside.
     * @param rectWidth Width of  to recognize barcode inside.
     * @param rectHeight Height of  to recognize barcode inside.
     * @param storage The image storage.
     * @param folder The image folder.
     */
    public async barCodeGetBarCodeRecognize (name: string, type?: string, checksumValidation?: string, stripFnc?: boolean, rotationAngle?: number, barcodesCount?: number, rectX?: number, rectY?: number, rectWidth?: number, rectHeight?: number, storage?: string, folder?: string) : Promise<{ response: http.ClientResponse; body: BarCodeResponseList;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/recognize'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling barCodeGetBarCodeRecognize.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (checksumValidation !== undefined) {
            localVarQueryParameters['checksumValidation'] = ObjectSerializer.serialize(checksumValidation, "string");
        }

        if (stripFnc !== undefined) {
            localVarQueryParameters['stripFnc'] = ObjectSerializer.serialize(stripFnc, "boolean");
        }

        if (rotationAngle !== undefined) {
            localVarQueryParameters['rotationAngle'] = ObjectSerializer.serialize(rotationAngle, "number");
        }

        if (barcodesCount !== undefined) {
            localVarQueryParameters['barcodesCount'] = ObjectSerializer.serialize(barcodesCount, "number");
        }

        if (rectX !== undefined) {
            localVarQueryParameters['rectX'] = ObjectSerializer.serialize(rectX, "number");
        }

        if (rectY !== undefined) {
            localVarQueryParameters['rectY'] = ObjectSerializer.serialize(rectY, "number");
        }

        if (rectWidth !== undefined) {
            localVarQueryParameters['rectWidth'] = ObjectSerializer.serialize(rectWidth, "number");
        }

        if (rectHeight !== undefined) {
            localVarQueryParameters['rectHeight'] = ObjectSerializer.serialize(rectHeight, "number");
        }

        if (storage !== undefined) {
            localVarQueryParameters['storage'] = ObjectSerializer.serialize(storage, "string");
        }

        if (folder !== undefined) {
            localVarQueryParameters['folder'] = ObjectSerializer.serialize(folder, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: BarCodeResponseList;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BarCodeResponseList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
    /**
     * 
     * @summary Recognize barcode from an url or from request body. Request body can contain raw data bytes of the image or encoded with base64.
     * @param type BarCode type.
     * @param checksumValidation Checksum validation parameter.
     * @param stripFnc Allows to strip FNC symbol in recognition results.
     * @param rotationAngle Recognition of rotated barcode. Possible angles are 90, 180, 270, default is 0
     * @param url The image file url.
     * @param imageData Image data with image
     */
    public async barCodePostBarCodeRecognizeFromUrlorContent (type?: string, checksumValidation?: string, stripFnc?: boolean, rotationAngle?: number, url?: string, imageData?: Buffer) : Promise<{ response: http.ClientResponse; body: BarCodeResponseList;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/recognize';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (checksumValidation !== undefined) {
            localVarQueryParameters['checksumValidation'] = ObjectSerializer.serialize(checksumValidation, "string");
        }

        if (stripFnc !== undefined) {
            localVarQueryParameters['stripFnc'] = ObjectSerializer.serialize(stripFnc, "boolean");
        }

        if (rotationAngle !== undefined) {
            localVarQueryParameters['rotationAngle'] = ObjectSerializer.serialize(rotationAngle, "number");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }


        let localVarUseFormData = false;

        if (imageData !== undefined) {
            localVarFormParams['imageData'] = imageData;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: BarCodeResponseList;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BarCodeResponseList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
    /**
     * 
     * @summary Generate multiple barcodes and return in response stream
     * @param dto List of barcodes
     * @param format Format to return stream in
     */
    public async barCodePostGenerateMultiple (dto?: BarCodeBuildersList, format?: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/generateMultiple';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (format !== undefined) {
            localVarQueryParameters['format'] = ObjectSerializer.serialize(format, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
            encoding: null,
            body: ObjectSerializer.serialize(dto, "BarCodeBuildersList")
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
    /**
     * 
     * @summary Generate barcode and save on server.
     * @param name The image name.
     * @param file File to upload
     * @param text BarCode&#39;s text.
     * @param type The barcode type.
     * @param format The image format.
     * @param resolutionX Horizontal resolution.
     * @param resolutionY Vertical resolution.
     * @param dimensionX Smallest width of barcode unit (bar or space).
     * @param dimensionY Smallest height of barcode unit (for 2D barcodes).
     * @param codeLocation property of the barcode. 
     * @param grUnit Measurement of barcode properties. 
     * @param autoSize Sets if barcode size will be updated automatically. 
     * @param barHeight Height of the bar. 
     * @param imageHeight Height of the image. 
     * @param imageWidth Width of the image. 
     * @param imageQuality Detepmines  of the barcode image. 
     * @param rotAngle Angle of barcode orientation. 
     * @param topMargin Top margin. 
     * @param bottomMargin Bottom margin. 
     * @param leftMargin Left margin. 
     * @param rightMargin Right margin. 
     * @param enableChecksum Sets if checksum will be generated.
     * @param storage Image&#39;s storage.
     * @param folder Image&#39;s folder.
     */
    public async barCodePutBarCodeGenerateFile (name: string, file: Buffer, text?: string, type?: string, format?: string, resolutionX?: number, resolutionY?: number, dimensionX?: number, dimensionY?: number, codeLocation?: string, grUnit?: string, autoSize?: string, barHeight?: number, imageHeight?: number, imageWidth?: number, imageQuality?: string, rotAngle?: number, topMargin?: number, bottomMargin?: number, leftMargin?: number, rightMargin?: number, enableChecksum?: string, storage?: string, folder?: string) : Promise<{ response: http.ClientResponse; body: AsposeResponse;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/generate'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling barCodePutBarCodeGenerateFile.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling barCodePutBarCodeGenerateFile.');
        }

        if (text !== undefined) {
            localVarQueryParameters['text'] = ObjectSerializer.serialize(text, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (format !== undefined) {
            localVarQueryParameters['format'] = ObjectSerializer.serialize(format, "string");
        }

        if (resolutionX !== undefined) {
            localVarQueryParameters['resolutionX'] = ObjectSerializer.serialize(resolutionX, "number");
        }

        if (resolutionY !== undefined) {
            localVarQueryParameters['resolutionY'] = ObjectSerializer.serialize(resolutionY, "number");
        }

        if (dimensionX !== undefined) {
            localVarQueryParameters['dimensionX'] = ObjectSerializer.serialize(dimensionX, "number");
        }

        if (dimensionY !== undefined) {
            localVarQueryParameters['dimensionY'] = ObjectSerializer.serialize(dimensionY, "number");
        }

        if (codeLocation !== undefined) {
            localVarQueryParameters['codeLocation'] = ObjectSerializer.serialize(codeLocation, "string");
        }

        if (grUnit !== undefined) {
            localVarQueryParameters['grUnit'] = ObjectSerializer.serialize(grUnit, "string");
        }

        if (autoSize !== undefined) {
            localVarQueryParameters['autoSize'] = ObjectSerializer.serialize(autoSize, "string");
        }

        if (barHeight !== undefined) {
            localVarQueryParameters['barHeight'] = ObjectSerializer.serialize(barHeight, "number");
        }

        if (imageHeight !== undefined) {
            localVarQueryParameters['imageHeight'] = ObjectSerializer.serialize(imageHeight, "number");
        }

        if (imageWidth !== undefined) {
            localVarQueryParameters['imageWidth'] = ObjectSerializer.serialize(imageWidth, "number");
        }

        if (imageQuality !== undefined) {
            localVarQueryParameters['imageQuality'] = ObjectSerializer.serialize(imageQuality, "string");
        }

        if (rotAngle !== undefined) {
            localVarQueryParameters['rotAngle'] = ObjectSerializer.serialize(rotAngle, "number");
        }

        if (topMargin !== undefined) {
            localVarQueryParameters['topMargin'] = ObjectSerializer.serialize(topMargin, "number");
        }

        if (bottomMargin !== undefined) {
            localVarQueryParameters['bottomMargin'] = ObjectSerializer.serialize(bottomMargin, "number");
        }

        if (leftMargin !== undefined) {
            localVarQueryParameters['leftMargin'] = ObjectSerializer.serialize(leftMargin, "number");
        }

        if (rightMargin !== undefined) {
            localVarQueryParameters['rightMargin'] = ObjectSerializer.serialize(rightMargin, "number");
        }

        if (enableChecksum !== undefined) {
            localVarQueryParameters['enableChecksum'] = ObjectSerializer.serialize(enableChecksum, "string");
        }

        if (storage !== undefined) {
            localVarQueryParameters['storage'] = ObjectSerializer.serialize(storage, "string");
        }

        if (folder !== undefined) {
            localVarQueryParameters['folder'] = ObjectSerializer.serialize(folder, "string");
        }


        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['File'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: AsposeResponse;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsposeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
    /**
     * 
     * @summary Recognition of a barcode from file on server with parameters in body.
     * @param name The image name.
     * @param barcodeReader BarCodeReader object with parameters.
     * @param type The barcode type.
     * @param folder The image folder.
     */
    public async barCodePutBarCodeRecognizeFromBody (name: string, barcodeReader?: BarCodeReader, type?: string, folder?: string) : Promise<{ response: http.ClientResponse; body: BarCodeResponseList;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/recognize'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling barCodePutBarCodeRecognizeFromBody.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (folder !== undefined) {
            localVarQueryParameters['folder'] = ObjectSerializer.serialize(folder, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
            body: ObjectSerializer.serialize(barcodeReader, "BarCodeReader")
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: BarCodeResponseList;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BarCodeResponseList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
    /**
     * 
     * @summary Generate image with multiple barcodes and put new file on server
     * @param name New filename
     * @param dto List of barcodes
     * @param format Format of file
     * @param folder Folder to place file to
     */
    public async barCodePutGenerateMultiple (name: string, dto?: BarCodeBuildersList, format?: string, folder?: string) : Promise<{ response: http.ClientResponse; body: AsposeResponse;  }> {
        const localVarPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/generateMultiple'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling barCodePutGenerateMultiple.');
        }

        if (format !== undefined) {
            localVarQueryParameters['format'] = ObjectSerializer.serialize(format, "string");
        }

        if (folder !== undefined) {
            localVarQueryParameters['folder'] = ObjectSerializer.serialize(folder, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            json: true,
            body: ObjectSerializer.serialize(dto, "BarCodeBuildersList")
        };

        await this._configuration.authentication.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.ClientResponse; body: AsposeResponse;  }>((resolve, reject) => {
			var handler =  async (error, response, body, allowRepeat) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsposeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
					else if (allowRepeat && response.statusCode && response.statusCode === 401){
						await this._configuration.authentication.applyUnauthorized();
						await handler(error, response, body, false);
					}
					else{
                        reject({ response: response, body: body });
                    }
                }
				};
            localVarRequest(localVarRequestOptions, (error, response, body) => handler(error, response, body, true) );
        });
    }
}
